// lib/supabase.ts

import { createClient } from "@/utils/supabase/client";

// The createClient function from Supabase is synchronous, so 'await' is not needed here.
export const supabase = createClient();

// --- Type Definitions ---
// These interfaces define the shape of your data.

export interface Ticket {
  id: string; // Typically a UUID generated by Postgres
  title: string;
  description: string;
  status: "open" | "in_progress" | "closed";
  priority: "low" | "medium" | "high" | "urgent";
  user_email: string;
  user_name: string;
  created_at: string; // ISO 8601 timestamp string
  updated_at: string; // ISO 8601 timestamp string
}

export interface Message {
  id: string; // Typically a UUID generated by Postgres
  ticket_id: string;
  sender_name: string;
  sender_email: string;
  content: string;
  is_admin: boolean;
  created_at: string; // ISO 8601 timestamp string
}

// --- Ticket Functions ---

/**
 * Creates a new support ticket.
 * @param ticket - The ticket data to insert. The id, created_at, and updated_at are handled by the database.
 * @returns The newly created ticket object.
 */
export const createTicket = async (
  ticket: Omit<Ticket, "id" | "created_at" | "updated_at">
): Promise<Ticket> => {
  console.log("Attempting to create a new ticket with title:", ticket.title);
  try {
    const { data, error } = await supabase
      .from("tickets")
      .insert([ticket])
      .select()
      .single();

    if (error) {
      // Re-throw the error to be caught by the calling function's catch block
      throw error;
    }

    console.log("Successfully created ticket with ID:", data.id);
    return data;
  } catch (error) {
    console.error("Error creating ticket:", error);
    // Re-throw the error so UI components can handle it (e.g., show an error message)
    throw new Error("Could not create the ticket.");
  }
};

/**
 * Fetches all tickets submitted by a specific user.
 * @param userEmail - The email of the user whose tickets are to be fetched.
 * @returns An array of ticket objects.
 */
export const getUserTickets = async (userEmail: string): Promise<Ticket[]> => {
  console.log(`Fetching all tickets for user: ${userEmail}`);
  try {
    const { data, error } = await supabase
      .from("tickets")
      .select("*")
      .eq("user_email", userEmail)
      .order("created_at", { ascending: false });

    if (error) {
      throw error;
    }

    console.log(
      `Successfully fetched ${data.length} tickets for user: ${userEmail}`
    );
    return data || []; // Return an empty array if data is null
  } catch (error) {
    console.error(`Error fetching tickets for user ${userEmail}:`, error);
    throw new Error("Could not fetch user tickets.");
  }
};

/**
 * Fetches all tickets from the database (for admin use).
 * @returns An array of all ticket objects.
 */
export const getAllTickets = async (): Promise<Ticket[]> => {
  console.log("Attempting to fetch all tickets for admin view.");
  try {
    const { data, error } = await supabase
      .from("tickets")
      .select("*")
      .order("created_at", { ascending: false });

    if (error) {
      throw error;
    }

    console.log(`Successfully fetched a total of ${data.length} tickets.`);
    return data || [];
  } catch (error) {
    console.error("Error fetching all tickets:", error);
    throw new Error("Could not fetch all tickets.");
  }
};

/**
 * Updates the status of a specific ticket.
 * @param ticketId - The ID of the ticket to update.
 * @param status - The new status for the ticket.
 * @returns The updated ticket object.
 */
export const updateTicketStatus = async (
  ticketId: string,
  status: Ticket["status"]
): Promise<Ticket> => {
  console.log(
    `Attempting to update status for ticket ID: ${ticketId} to "${status}"`
  );
  try {
    const { data, error } = await supabase
      .from("tickets")
      .update({ status, updated_at: new Date().toISOString() })
      .eq("id", ticketId)
      .select()
      .single();

    if (error) {
      throw error;
    }

    console.log(`Successfully updated status for ticket ID: ${ticketId}`);
    return data;
  } catch (error) {
    console.error(`Error updating status for ticket ${ticketId}:`, error);
    throw new Error("Could not update the ticket status.");
  }
};

/**
 * Fetches a single ticket by its ID.
 * @param ticketId - The ID of the ticket to fetch.
 * @returns The ticket object.
 */
export const getTicket = async (ticketId: string): Promise<Ticket> => {
  console.log(`Fetching details for ticket ID: ${ticketId}`);
  try {
    const { data, error } = await supabase
      .from("tickets")
      .select("*")
      .eq("id", ticketId)
      .single();

    if (error) {
      throw error;
    }

    console.log(`Successfully fetched details for ticket ID: ${ticketId}`);
    return data;
  } catch (error) {
    console.error(`Error fetching ticket ${ticketId}:`, error);
    throw new Error("Could not fetch the ticket details.");
  }
};

// --- Message Functions ---

/**
 * Sends a new message associated with a ticket.
 * @param message - The message data to insert. The id and created_at are handled by the database.
 * @returns The newly created message object.
 */
export const sendMessage = async (
  message: Omit<Message, "id" | "created_at">
): Promise<Message> => {
  console.log(`Attempting to send message for ticket ID: ${message.ticket_id}`);
  try {
    const { data, error } = await supabase
      .from("ticket_messages")
      .insert([message])
      .select()
      .single();

    if (error) {
      throw error;
    }

    console.log("Successfully sent and saved message with ID:", data.id);
    return data;
  } catch (error) {
    console.error("Error sending message:", error);
    throw new Error("Could not send the message.");
  }
};

/**
 * Fetches all messages for a specific ticket.
 * @param ticketId - The ID of the ticket whose messages are to be fetched.
 * @returns An array of message objects.
 */
export const getTicketMessages = async (
  ticketId: string
): Promise<Message[]> => {
  console.log(`Fetching all messages for ticket ID: ${ticketId}`);
  try {
    const { data, error } = await supabase
      .from("ticket_messages")
      .select("*")
      .eq("ticket_id", ticketId)
      .order("created_at", { ascending: true });

    if (error) {
      throw error;
    }

    console.log(
      `Successfully fetched ${data.length} messages for ticket ID: ${ticketId}`
    );
    return data || [];
  } catch (error) {
    console.error(`Error fetching messages for ticket ${ticketId}:`, error);
    throw new Error("Could not fetch ticket messages.");
  }
};
